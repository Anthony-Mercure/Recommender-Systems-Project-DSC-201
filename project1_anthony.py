# -*- coding: utf-8 -*-
"""Project1_Anthony.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZXsJhR8octzdeG40NabN972m_nIT6xZe

# **Project 1: Suggesting Music Playlists**

*Anthony J. Mercure*

##**Introduction of the data set and data variables**

url = https://www.aicrowd.com/challenges/spotify-million-playlist-dataset-challenge

*C.W. Chen, P. Lamere, M. Schedl, and H. Zamani. Recsys Challenge 2018: Automatic Music Playlist Continuation. In Proceedings of the 12th ACM Conference on Recommender Systems (RecSys â€™18), 2018.*

The Spotify Million Playlist Dataset was collected and released by Spotify for research in music recommendations. The dataset has of 1,000,000 playlists created by users on Spotify between January 2010 and October 2017. The data is sampled from over 4 billion public playlists available on Spotify, which were anonymized to protect user privacy.
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import json
import os
import random
from collections import Counter
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.neighbors import NearestNeighbors
from scipy.sparse.linalg import svds
from sklearn.feature_extraction.text import TfidfVectorizer

# Mount your google drive
from google.colab import drive
drive.mount('/content/drive')

# %cd /content/drive/MyDrive/DSC201/Data/Spotify_Research_Dataset

data_path = "/content/drive/MyDrive/DSC201/Data/Spotify_Research_Dataset/"

all_data = []

for i in range(12):
    file_path = os.path.join(data_path, f"mpd.slice.{i*1000}-{(i+1)*1000-1}.json")
    with open(file_path, 'r') as file:
        data = json.load(file)
        all_data.extend(data['playlists'])

df = pd.DataFrame(all_data)

df.head()

df.iloc[15]['tracks']

df.shape

df.info()

"""Although there one million playlists in the dataset, for ease of computing, 12 000 will be used. There are 12 columns for each playlist, of which they are the playlist's name, the id, the modified at timestamp when last updated, whether or not the playlist is open to public collaboration, the number of songs contained, number of albums, number of followers, the tracks, number of times the playlist has been edited, the duration in milliseconds, and the optional description. The tracks column contains entries of individual songs in the playlists, giving the position in the playlist, artist name, song name, albumn name, duration in milliseconds, and the Spotify affiliated uri to find the specific artist, song, and albumn in the Spotify database."""

# Define the number of users and demographic percentages
total_users = 1000
gender_percentages = {'Male': 0.45, 'Female': 0.54, 'Unspecified': 0.005, 'Nonbinary': 0.005}
age_percentages = {'13-17': 0.10, '18-24': 0.43, '25-34': 0.31, '35-44': 0.09, '45-54': 0.04, '55+': 0.03}

# Create an empty DataFrame
user_data = pd.DataFrame(columns=['user_id', 'gender', 'age', 'pid', 'rating'])

# Generate user data
user_id = 1

for gender, gender_percentage in gender_percentages.items():
    for age, age_percentage in age_percentages.items():
        num_users = int(total_users * gender_percentage * age_percentage)
        user_ids = list(range(user_id, user_id + num_users))
        genders = [gender] * num_users
        ages = [age] * num_users

        # Generate a realistic number of playlists rated for each user
        playlists_rated = np.random.randint(10, 101, size=num_users)

        # Generate random ratings (1 to 5) and playlist IDs (1 to 300,000)
        playlist_ids = np.random.randint(1, 12001, size=np.sum(playlists_rated))
        ratings = np.random.randint(1, 6, size=np.sum(playlists_rated))

        # Create a DataFrame for this demographic group
        demographic_df = pd.DataFrame({'user_id': np.repeat(user_ids, playlists_rated),
                                       'gender': np.repeat(genders, playlists_rated),
                                       'age': np.repeat(ages, playlists_rated),
                                       'pid': playlist_ids,
                                       'rating': ratings})

        # Append to the user_data DataFrame
        user_data = pd.concat([user_data, demographic_df], ignore_index=True)

        user_id += num_users

# Shuffle the DataFrame
user_data = user_data.sample(frac=1, random_state=42).reset_index(drop=True)
user_data = user_data.sort_values(by=['user_id', 'pid'], ascending=True)

user_data.head(10)

user_data.shape

"""For collaborative recommendations, a synthetic user usage data is created, with a varying size each time it is generated. Based on the demographics of gender and age provided with the dataset, the users are assigned to rate a number of playlists, between 10 and 101. The ratings are between 1 and 5, for which depending on the number of playlists rated, a random playlist is assigned.

##**Research Hypotheses**

- The goal of this project is to use content-based, collaborative, and hybrid recommending systems to provide personalized playlist recommendations to users based on their preferences of playlist.

##**Data Cleaning & Preprocessing**

### Missing Values
"""

df.isnull().sum()

"""All columns of the dataset are not null, except for the description column. However, on the Spotify platform, the description of a playlist is optional and many users opt not to create one.

### Duplicate Values
"""

user_data.drop_duplicates(subset=['user_id', 'pid'])

"""The synthetic user_data that was generated may contain duplicate instances where the user has rated a playlist more than once. Dropping duplicates fixes any future issues that these duplicates may create.

### Column Separation
"""

def listdict_to_artist(x):
  list=[]
  for dict in x:
    list.append(dict['artist_name'])
  return ' | '.join(list)

df['artists'] = df['tracks'].apply(listdict_to_artist)

def listdict_to_track(x):
  list=[]
  for dict in x:
    list.append(dict['track_name'])
  return ' | '.join(list)

df['songs'] = df['tracks'].apply(listdict_to_track)

def listdict_to_album(x):
  list=[]
  for dict in x:
    list.append(dict['album_name'])
  return ' | '.join(list)

df['albums'] = df['tracks'].apply(listdict_to_album)

df['artists'].iloc[0]

df['songs'].iloc[0]

df['albums'].iloc[0]

"""Methods are created and implemented to seperate the artists, songs, and albums from the tracks column into their own respective columns.

##**Methods for Finding a Playlist and Viewing Songs**
"""

def find_top_playlists_with_artist(artist_name, df, top_n=10):
    artist_counter = Counter()

    found = False
    for index, row in df.iterrows():
        artists = row['artists'].split(" | ")
        if artist_name in artists:
            found = True
            artist_counter.update([row['name']])

    if not found:
        return ["Sorry, this artist is not contained in this dataset."]

    top_playlists = artist_counter.most_common(top_n)

    top_playlist_names = [playlist for playlist, _ in top_playlists]

    return top_playlist_names

# Examples: "The Smiths", "Connie Francis", "Dean Martin"
user_input_artist = input("Enter an artist name: ")
top_playlists = find_top_playlists_with_artist(user_input_artist, df, top_n=10)

print(f"The ten playlists where '{user_input_artist}' appears most often are:")
for playlist in top_playlists:
    print(playlist)

def print_songs_in_playlist(playlist_name, df, num_songs=15):
    # Find the row that matches the specified playlist name
    playlist_row = df[df['name'] == playlist_name]

    # Check if the playlist was found
    if not playlist_row.empty:
        songs_string = playlist_row.iloc[0]['songs']  # Get the songs string
        songs_list = songs_string.split(" | ")  # Split the songs by "|"

        # Print the names of the first 10 songs in the playlist
        print(f"Songs in the playlist '{playlist_name}':")
        print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
        for song in songs_list[:num_songs]:
            print(song)
        print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
    else:
        print(f"Playlist '{playlist_name}' not found in the dataset.")

user_input_playlist = input("Enter a playlist name: ")
print_songs_in_playlist(user_input_playlist, df, num_songs=15)

"""The first method offers the user the chance to choose a playlist based on a specified artist, returning the 10 playlists that this artist appears in most. The second method allows the user to view some songs in a specified playlist, so the user may view some songs in a recommended playlist.

##**Part I: Content-Based Recommender**
"""

def combined_features(row):
    return row['artists']+ " "+row['songs']+" " +row['albums']

df['combined_features'] = df.apply(combined_features, axis =1)

df['combined_features'].head(10)

def get_index_from_name(name):
    return df[df.name == name]["pid"].values[0]

def get_name_from_index(index):
    return df[df.index == index]["name"].values[0]

def content_recommendation(title, k=10):
    recommended_playlists = set()
    recommended_count = 0

    # Create a CountVectorizer and calculate the cosine similarity
    count_vector = CountVectorizer()
    count_matrix = count_vector.fit_transform(df['combined_features'])
    cosine_sim = cosine_similarity(count_matrix)

    # Get the index for the input title
    name_index = get_index_from_name(title)

    # Calculate the similarity between the input title and all other titles
    similar_playlists = list(enumerate(cosine_sim[name_index]))

    # Sort playlists by similarity
    sorted_similar_playlists = sorted(similar_playlists, key=lambda x: x[1], reverse=True)

    print(f"Recommended playlists for {title} are:")
    print("**********************************************************")

    for playlist in sorted_similar_playlists:
        recommended_playlist = get_name_from_index(playlist[0])

        if recommended_playlist not in recommended_playlists:
            # Recommend the playlist if it's not in the set
            print(recommended_playlist)
            recommended_playlists.add(recommended_playlist)
            recommended_count += 1

        if recommended_count >= k:
            # Stop recommending when reaching k recommendations
            break

    print("**********************************************************")

# Examples of playlist names: "doo wop", "Golden years", "Wedding"
playlist_title = input("Enter a playlist name: ")
content_recommendation(playlist_title, k=10)

user_input_playlist = input("Enter a playlist name: ")
print_songs_in_playlist(user_input_playlist, df, num_songs=15)

"""With the content-based recommender, users are allowed to choose a specified playlist, for which 10 recommended playlists will be returned, given the option of choosing one of these new playlists to see some of the songs that it contains.

##**Part II: Collaborative-Based Recommender**
"""

# Create a user-item rating matrix
user_playlist_ratings = user_data.drop_duplicates(subset=['user_id', 'pid']).pivot(index='user_id', columns='pid', values='rating').fillna(0)
user_playlist_ratings.index = user_playlist_ratings.index.astype(int)
user_playlist_ratings.columns = user_playlist_ratings.columns.astype(int)

#  Calculate the mean rating of each user
user_playlist_mean = user_playlist_ratings.mean(axis=1)

# Normalize the user-item rating matrix by subtracting the mean rating of each user
user_playlist_ratings_normalized = user_playlist_ratings.sub(user_playlist_mean, axis=0)

# Convert the DataFrame to a NumPy array
user_playlist_ratings_array = user_playlist_ratings_normalized.values

# Perform Singular Value Decomposition (SVD)
U, sigma, Vt = svds(user_playlist_ratings_array, k=75)

# Convert sigma to a diagonal matrix
sigma_diag_matrix = np.diag(sigma)

# Reconstruct the predicted ratings
predicted_ratings = np.dot(np.dot(U, sigma_diag_matrix), Vt) + user_playlist_mean.values.reshape(-1, 1)

# Create a DataFrame for predicted ratings
predicted_ratings_df = pd.DataFrame(predicted_ratings,
                                    columns=user_playlist_ratings.columns,
                                    index=user_playlist_ratings.index)

# Define a function to get playlist recommendations for a given user
def collaborative_recommendation(user_id, num_recommendations=10):

    # Get the user's predicted ratings
    user_predicted_ratings = predicted_ratings_df.loc[user_id]

    # Find playlists that the user has not already rated
    unrated_playlists = user_playlist_ratings.loc[user_id][user_playlist_ratings.loc[user_id] == 0].index

    # Get the predicted ratings for those unrated playlists and sort them in descending order
    top_rated_playlists = user_predicted_ratings[unrated_playlists].sort_values(ascending=False).index

    # Choose the top k playlists for recommendation
    recommended_playlists = top_rated_playlists[:num_recommendations]

    print(f"Recommended playlists for user {user_id}:")
    print("*********************************************")
    for playlist_id in recommended_playlists:
        playlist_title = df[df['pid'] == playlist_id]['name'].values[0]
        print(playlist_title)
    print("*********************************************")

user_id= input(f'Enter a user id: ')
user_id = int(user_id)

collaborative_recommendation(user_id, num_recommendations=10)

user_input_playlist = input("Enter a playlist name: ")
print_songs_in_playlist(user_input_playlist, df, num_songs=15)

"""With the collaborative recommender, a user is chosen, for which 10 recommended playlists will be returned based upon those playlists that the specified user has rated, then the user is given the option of choosing one of these new playlists to see some of the songs that it contains.

##**Part III: Hybrid Recommender**
"""

# Vectorize the content
tfidf = TfidfVectorizer(stop_words='english')
content_matrix = tfidf.fit_transform(df['combined_features'])

cosine_sim = cosine_similarity(content_matrix)

# Get the user's predicted ratings for the given index
user_predicted_ratings = predicted_ratings_df.loc[user_id]

def get_pid_from_index(index):
    return df[df.index == index]["pid"].values[0]
def get_index_from_title(title):
    return df[df.name == title].index[0]

def hybrid_recommendation(user_id, title, k=10):
    # k: number of recommended playlists

    # Get the index from the title
    playlist_index = get_index_from_name(title)

    # Pairwise cosine value for the given playlist index
    pairwise_cosine = list(enumerate(cosine_sim[playlist_index]))

    # Select the first 25 playlists with the highest cosine value
    sorted_cosine = sorted(pairwise_cosine,
                           key=lambda x: x[1],
                           reverse=True)[1:26]

    # Store indices for playlists with high cosine value
    playlist_indices = [i[0] for i in sorted_cosine]

    # Get playlist id from playlist_indices
    playlist_ids = [get_pid_from_index(i) for i in playlist_indices]

    # Get predicted value of the playlist for the user
    predicted_rating = [predicted_ratings_df.loc[user_id][i] for i in playlist_ids]

    # Create a DataFrame with playlist_ids and predicted values
    playlist_rating = pd.DataFrame({'playlist_id': playlist_ids, 'pred_ratings': predicted_rating})

    # Sort the DataFrame based on 'pred_ratings'
    sorted_playlist_rating = playlist_rating.sort_values(by='pred_ratings', ascending=False)

    # Getting a list of top k playlist's playlist id
    top_k_playlist_ids = sorted_playlist_rating['playlist_id'].values[0:k].tolist()

    # Create a set to store recommended playlists and exclude duplicates
    recommended_playlists = set()
    recommended_playlists.add(title)  # Exclude the input playlist title

    print(f"Recommended playlists for user {user_id} and playlist: {title} are")
    print("*********************************************")

    for playlist_id in top_k_playlist_ids:
        playlist_title = df[df['pid'] == playlist_id]['name'].values[0]
        if playlist_title not in recommended_playlists:
            # Recommend the playlist if it's not the input playlist or a duplicate
            print(playlist_title)
            recommended_playlists.add(playlist_title)

    print("*********************************************")

user_id= input(f'Enter a user id: ')
user_id = int(user_id)
playlist_name= input(f'Enter a playlist name: ')

hybrid_recommendation(user_id, playlist_name, k=10)

user_input_playlist = input("Enter a playlist name: ")
print_songs_in_playlist(user_input_playlist, df, num_songs=15)

"""With the hybrid recommender, a user and specified playlist is chosen, for which 10 recommended playlists will be returned based upon those playlists that the specified user has rated in conjunction with the recommendations affiliated with the playlist, also with the option of selecting one of the new playlists to view some of the songs it contains.

##**Conclusion**##

- Overall, in using the Spotify Million Playlist Dataset, the three recommendation systems were able to implement themselves to effectively suggest similar playlists to a specified one, recommend playlists based on a user's previous preferences, and combine these methods for a recommendation of a user's chosen playlist and rating history.
"""